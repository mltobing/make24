<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="color-scheme" content="dark">
    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Make 24</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Space+Mono:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

```
:root {
    --cyan: #22d3ee;
    --cyan-dark: #0891b2;
    --cyan-glow: rgba(34, 211, 238, 0.3);
    --bg: #0f172a;
    --card-bg: #1e293b;
    --card-border: #334155;
    --text: #f1f5f9;
    --text-muted: #94a3b8;
    --success: #10b981;
    --error: #ef4444;
    --warning: #f59e0b;
    --gold: #fbbf24;
    color-scheme: dark;
}

html, body {
    height: 100%;
    overflow: hidden;
    background: #0f172a;
    overscroll-behavior: none;
    -webkit-overflow-scrolling: auto;
}

html {
    position: fixed;
    width: 100%;
}

body {
    font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
    background: #0f172a;
    color: #f1f5f9;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100dvh;
    padding: 16px;
    padding-bottom: env(safe-area-inset-bottom, 16px);
    touch-action: manipulation;
    -webkit-user-select: none;
    user-select: none;
}

/* Header */
.header {
    width: 100%;
    max-width: 400px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    margin-bottom: 24px;
    position: relative;
    z-index: 5;
}

.puzzle-number {
    font-family: 'Space Mono', monospace;
    font-size: 1.5rem;
    font-weight: 700;
    color: #22d3ee;
    cursor: pointer;
    transition: opacity 0.2s;
}

.puzzle-number:hover {
    opacity: 0.8;
}

.header-right {
    display: flex;
    align-items: center;
    gap: 16px;
}

.undo-btn {
    font-size: 1.5rem;
    color: #94a3b8;
    background: none;
    border: none;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s, color 0.2s;
    padding: 4px;
    pointer-events: none;
}

.undo-btn.visible {
    opacity: 0.6;
    pointer-events: auto;
}

.undo-btn.visible:hover {
    opacity: 1;
    color: #22d3ee;
}

.undo-btn.visible:active {
    transform: scale(0.9);
}

/* Hint button */
.hint-btn {
    font-size: 1.25rem;
    color: #94a3b8;
    background: none;
    border: none;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.6s ease-in, color 0.2s;
    padding: 4px;
    pointer-events: none;
}

.hint-btn.visible {
    opacity: 0.5;
    pointer-events: auto;
    animation: hint-pulse 2s ease-in-out infinite;
}

.hint-btn.visible:hover {
    opacity: 1;
    color: #f59e0b;
}

@keyframes hint-pulse {
    0%, 100% { opacity: 0.35; }
    50% { opacity: 0.65; }
}

/* Sync section in archive modal */
.sync-section {
    margin-top: 12px;
    padding: 12px;
    background: rgba(34, 211, 238, 0.05);
    border: 1px solid #334155;
    border-radius: 8px;
    text-align: center;
}

.sync-section.signed-in {
    border-color: rgba(34, 211, 238, 0.3);
}

.sync-label {
    font-size: 0.75rem;
    color: #64748b;
    margin-bottom: 8px;
}

.sync-methods {
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: center;
}

.google-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    width: 100%;
    padding: 9px 12px;
    background: #fff;
    border: 1px solid #dadce0;
    border-radius: 8px;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.8125rem;
    font-weight: 600;
    color: #3c4043;
    cursor: pointer;
    transition: background 0.15s, box-shadow 0.15s;
}

.google-btn:hover {
    background: #f7f8f8;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
}

.google-btn svg {
    width: 16px;
    height: 16px;
    flex-shrink: 0;
}

.sync-divider {
    font-size: 0.6875rem;
    color: #475569;
    display: flex;
    align-items: center;
    gap: 8px;
    width: 100%;
}

.sync-divider::before,
.sync-divider::after {
    content: '';
    flex: 1;
    height: 1px;
    background: #334155;
}

.email-otp-row {
    display: flex;
    gap: 6px;
    width: 100%;
}

.email-otp-input {
    flex: 1;
    padding: 8px 10px;
    background: #0f172a;
    border: 1px solid #334155;
    border-radius: 6px;
    color: #f1f5f9;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.8125rem;
    outline: none;
    transition: border-color 0.15s;
}

.email-otp-input:focus {
    border-color: #22d3ee;
}

.email-otp-input::placeholder {
    color: #475569;
}

.email-send-btn {
    padding: 8px 12px;
    background: rgba(34, 211, 238, 0.15);
    border: 1px solid #22d3ee;
    border-radius: 6px;
    color: #22d3ee;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.75rem;
    font-weight: 600;
    cursor: pointer;
    white-space: nowrap;
    transition: background 0.15s;
}

.email-send-btn:hover {
    background: rgba(34, 211, 238, 0.25);
}

.email-send-btn:disabled {
    opacity: 0.4;
    cursor: default;
}

/* OTP code entry (hidden until email sent) */
.otp-verify-row {
    display: none;
    gap: 6px;
    width: 100%;
}

.otp-verify-row.visible {
    display: flex;
}

.otp-code-input {
    flex: 1;
    min-width: 0;
    padding: 8px 10px;
    background: #0f172a;
    border: 1px solid #334155;
    border-radius: 6px;
    color: #f1f5f9;
    font-family: 'Space Mono', monospace;
    font-size: 1rem;
    letter-spacing: 0.15em;
    text-align: center;
    outline: none;
    transition: border-color 0.15s;
}

.otp-code-input:focus {
    border-color: #22d3ee;
}

.otp-code-input::placeholder {
    color: #475569;
    letter-spacing: 0.1em;
    font-size: 0.8125rem;
}

.otp-verify-btn {
    padding: 8px 16px;
    background: #22d3ee;
    border: none;
    border-radius: 6px;
    color: #0f172a;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.875rem;
    font-weight: 700;
    cursor: pointer;
    transition: background 0.15s;
    white-space: nowrap;
    min-width: 64px;
    flex-shrink: 0;
}

.otp-verify-btn:hover {
    background: #0891b2;
}

.sync-status {
    font-size: 0.6875rem;
    color: #64748b;
    min-height: 1em;
    margin-top: 4px;
}

.sync-status.error { color: #ef4444; }
.sync-status.success { color: #10b981; }

.sync-signout {
    background: none;
    border: none;
    color: #64748b;
    font-family: 'DM Sans', sans-serif;
    font-size: 0.75rem;
    cursor: pointer;
    padding: 4px 8px;
    border-radius: 6px;
    transition: color 0.15s;
}

.sync-signout:hover {
    color: #94a3b8;
}

/* Streak milestone nudge toast */
.sync-nudge {
    position: fixed;
    bottom: 70px;
    left: 50%;
    transform: translateX(-50%) translateY(20px);
    background: #1e293b;
    border: 1px solid #334155;
    border-radius: 12px;
    padding: 10px 16px;
    font-size: 0.8125rem;
    color: #94a3b8;
    text-align: center;
    z-index: 80;
    max-width: 300px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s, transform 0.4s;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
}

.sync-nudge.visible {
    opacity: 1;
    pointer-events: auto;
    transform: translateX(-50%) translateY(0);
}

.sync-nudge-link {
    color: #22d3ee;
    text-decoration: underline;
    cursor: pointer;
    font-weight: 500;
}

.sync-nudge-dismiss {
    color: #475569;
    font-size: 0.75rem;
    cursor: pointer;
    margin-left: 8px;
}

.streak-display {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 1.25rem;
    font-weight: 700;
}

.streak-display .fire {
    font-size: 1.5rem;
}

.freeze-indicator {
    font-size: 1rem;
    margin-left: 4px;
    opacity: 0.8;
}

/* Game Container */
.game-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100%;
    max-width: 400px;
    position: relative;
    margin-top: -80px;
}

.result-display {
    font-family: 'Space Mono', monospace;
    font-size: 3.5rem;
    font-weight: 700;
    color: #f1f5f9;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: color 0.3s, transform 0.2s, opacity 0.3s;
    margin-bottom: 24px;
    opacity: 0;
}

.result-display.visible { opacity: 1; }
.result-display.success { color: #10b981; transform: scale(1.1); }
.result-display.error { color: #ef4444; }

/* Clean win state: hide cards, show big result */
.result-display.win-clean {
    font-size: 5rem;
    color: #10b981;
    opacity: 1;
    transform: scale(1);
    animation: win-pulse 0.6s ease-out;
}

@keyframes win-pulse {
    0% { transform: scale(0.8); opacity: 0.5; }
    50% { transform: scale(1.15); }
    100% { transform: scale(1); opacity: 1; }
}

.diamond-grid.win-hidden .slot {
    opacity: 0;
    transform: scale(0.5);
    transition: opacity 0.4s ease, transform 0.4s ease;
}

/* Hint display */
.hint-display {
    font-family: 'DM Sans', sans-serif;
    font-size: 0.875rem;
    color: #f59e0b;
    opacity: 0;
    transition: opacity 0.5s;
    margin-top: -16px;
    margin-bottom: 8px;
    height: 20px;
}

.hint-display.visible {
    opacity: 0.7;
}

/* Diamond Grid */
.diamond-grid {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    grid-template-rows: 1fr 1fr 1fr;
    gap: 12px;
    width: 320px;
    height: 320px;
    position: relative;
}

.slot { display: flex; align-items: center; justify-content: center; transition: opacity 0.4s ease, transform 0.4s ease; }
.slot.top { grid-column: 2; grid-row: 1; }
.slot.left { grid-column: 1; grid-row: 2; }
.slot.right { grid-column: 3; grid-row: 2; }
.slot.bottom { grid-column: 2; grid-row: 3; }

.card {
    width: 96px;
    height: 96px;
    background: #1e293b;
    border: 2px solid #334155;
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: 'Space Mono', monospace;
    font-size: 2.75rem;
    font-weight: 700;
    color: #f1f5f9;
    cursor: pointer;
    transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
    -webkit-user-select: none;
    user-select: none;
}

.card:active { transform: scale(0.95); }
.card.selected { border-color: #22d3ee; box-shadow: 0 0 24px rgba(34, 211, 238, 0.3); transform: scale(1.08); }
.card.selected.first { border-color: #22d3ee; }
.card.selected.second { border-color: #f59e0b; box-shadow: 0 0 24px rgba(245, 158, 11, 0.3); }
.card.used { opacity: 0; pointer-events: none; transform: scale(0.8); }

/* Operators Overlay */
.operators-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(15, 23, 42, 0.4);
    display: none; align-items: center; justify-content: center; z-index: 50;
}
.operators-overlay.show { display: flex; }

.operators-grid {
    display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;
    gap: 12px; padding: 14px;
    background: rgba(30, 41, 59, 0.85); border-radius: 20px;
    border: 1px solid rgba(51, 65, 85, 0.6);
}

.op-btn {
    width: 54px; height: 54px; border-radius: 50%;
    border: 2px solid #22d3ee; background: rgba(30, 41, 59, 0.95);
    color: #f1f5f9; font-size: 1.5rem; font-weight: 700;
    cursor: pointer; transition: all 0.15s ease;
    display: flex; align-items: center; justify-content: center;
}
.op-btn:hover { background: rgba(34, 211, 238, 0.2); transform: scale(1.1); }
.op-btn:active { transform: scale(0.95); }

/* Move dots */
.move-dots {
    position: fixed; bottom: 40px; left: 50%; transform: translateX(-50%);
    display: flex; gap: 6px; justify-content: center; align-items: center;
}

.move-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: #334155; transition: background 0.3s, transform 0.2s;
}
.move-dot.filled { background: #10b981; transform: scale(1.1); }
.move-dot.excess { background: #64748b; }
.move-dot.perfect-hint { background: #334155; opacity: 0.5; }

/* Message overlay */
.message {
    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: #1e293b; border: 2px solid #22d3ee; border-radius: 16px;
    padding: 32px; text-align: center; z-index: 100;
    max-width: 90%; width: 320px;
    box-shadow: 0 0 40px rgba(34, 211, 238, 0.3); display: none;
}
.message.show { display: block; animation: popIn 0.3s ease; }

@keyframes popIn {
    from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
}

.message h2 { font-size: 1.5rem; margin-bottom: 8px; color: #f1f5f9; }
.message h2.perfect { color: #fbbf24; }
.message p { color: #94a3b8; margin-bottom: 16px; }
.message .stats { font-family: 'Space Mono', monospace; font-size: 1.25rem; margin: 16px 0; color: #f1f5f9; }
.message .percentile { font-size: 0.9rem; color: #94a3b8; margin-bottom: 16px; min-height: 1.2em; }
.message .percentile.highlight { color: #22d3ee; font-weight: 600; }

/* Difficulty badge in success modal */
.difficulty-badge {
    display: inline-block;
    font-size: 0.75rem;
    padding: 3px 10px;
    border-radius: 12px;
    margin-bottom: 12px;
    font-weight: 600;
    background: rgba(148, 163, 184, 0.15);
    color: #94a3b8;
}

.message .btn { margin-top: 8px; }

.btn {
    padding: 12px 24px; border-radius: 8px; border: none;
    font-family: 'DM Sans', sans-serif; font-size: 1rem; font-weight: 600;
    cursor: pointer; transition: all 0.15s ease;
}
.btn-primary { background: #22d3ee; color: #0f172a; }
.btn-primary:hover { background: #0891b2; }
.btn-secondary { background: #1e293b; color: #f1f5f9; border: 1px solid #334155; margin-left: 8px; }

/* Button row in success modal */
.btn-row {
    display: flex;
    gap: 8px;
    justify-content: center;
    flex-wrap: wrap;
    margin-top: 12px;
}

.btn-row .btn {
    margin: 0;
    font-size: 0.875rem;
    padding: 10px 16px;
}

.btn-challenge {
    background: transparent;
    color: #f59e0b;
    border: 1px solid #f59e0b;
}
.btn-challenge:hover {
    background: rgba(245, 158, 11, 0.15);
}

/* Archive Modal */
.modal-overlay {
    position: fixed; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    display: none; align-items: center; justify-content: center;
    z-index: 200; padding: 16px;
}
.modal-overlay.show { display: flex; }

.modal {
    background: #1e293b; border-radius: 16px; padding: 24px;
    max-width: 360px; width: 100%; max-height: 80vh; overflow-y: auto;
}
.modal h2 { text-align: center; margin-bottom: 16px; color: #22d3ee; }

.archive-list {
    display: grid; grid-template-columns: repeat(5, 1fr);
    gap: 8px; max-height: 320px; overflow-y: auto; padding-right: 4px;
}

.archive-list::-webkit-scrollbar { width: 6px; }
.archive-list::-webkit-scrollbar-track { background: #1e293b; border-radius: 3px; }
.archive-list::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }

.load-more-btn {
    display: block; width: 100%; margin-top: 12px; padding: 10px;
    background: transparent; border: 1px dashed #475569; border-radius: 8px;
    color: #94a3b8; font-family: 'DM Sans', sans-serif; font-size: 0.875rem;
    cursor: pointer; transition: all 0.15s;
}
.load-more-btn:hover { border-color: #22d3ee; color: #22d3ee; }

.share-history-btn {
    display: block; width: 100%; margin-top: 12px; padding: 10px;
    background: rgba(34, 211, 238, 0.1); border: 1px solid #22d3ee; border-radius: 8px;
    color: #22d3ee; font-family: 'DM Sans', sans-serif; font-size: 0.875rem;
    font-weight: 600; cursor: pointer; transition: all 0.15s;
}
.share-history-btn:hover { background: rgba(34, 211, 238, 0.2); }

.archive-item {
    aspect-ratio: 1; display: flex; align-items: center; justify-content: center;
    background: #0f172a; border: 1px solid #334155; border-radius: 8px;
    font-family: 'Space Mono', monospace; font-size: 0.875rem;
    color: #f1f5f9; cursor: pointer; transition: all 0.15s;
}
.archive-item:hover { border-color: #22d3ee; }

.archive-item.completed { background: rgba(16, 185, 129, 0.2); border-color: #10b981; }

.archive-item.perfect {
    background: rgba(251, 191, 36, 0.15); border-color: #fbbf24; position: relative;
}
.archive-item.perfect::after {
    content: '‚≠ê'; position: absolute; top: -4px; right: -4px; font-size: 0.6rem;
}

.archive-item.fast-perfect {
    background: rgba(251, 191, 36, 0.3); border-color: #fbbf24; position: relative;
    box-shadow: 0 0 8px rgba(251, 191, 36, 0.4);
}
.archive-item.fast-perfect::after {
    content: '‚≠ê‚≠ê'; position: absolute; top: -6px; right: -8px; font-size: 0.5rem;
}

.archive-item.today { border-color: #22d3ee; box-shadow: 0 0 10px rgba(34, 211, 238, 0.3); }

.archive-item.locked { cursor: default; position: relative; }
.archive-item.locked::before {
    content: 'üîí'; position: absolute; bottom: -4px; left: -4px; font-size: 0.5rem; opacity: 0.7;
}

.modal-close {
    display: block; width: 100%; margin-top: 16px; padding: 12px;
    background: #0f172a; border: 1px solid #334155; border-radius: 8px;
    color: #f1f5f9; font-size: 1rem; cursor: pointer;
}

/* Confetti */
.confetti-container {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    pointer-events: none; z-index: 1000; overflow: hidden;
}
.confetti { position: absolute; width: 10px; height: 10px; opacity: 0; }

@keyframes confetti-fall {
    0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
    100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

/* Archive mode indicator */
.archive-banner {
    background: #f59e0b; color: #0f172a; padding: 8px 16px; border-radius: 8px;
    font-size: 0.875rem; font-weight: 600;
    position: fixed; top: 60px; left: 50%; transform: translateX(-50%);
    display: none; z-index: 10;
}
.archive-banner.show { display: block; }

/* Hidden canvas for share image generation */
.share-canvas { display: none; }
```

</style>
</head>
<body>
    <div class="header">
        <div class="puzzle-number" id="puzzleNumber" title="Tap for archive">#</div>
        <div class="header-right">
            <button class="hint-btn" id="hintBtn" title="Get a hint">üí°</button>
            <button class="undo-btn" id="undoBtn" title="Undo">‚Ü∂</button>
            <div class="streak-display">
                <span class="fire">üî•</span>
                <span id="streakCount">0</span>
                <span class="freeze-indicator" id="freezeIndicator"></span>
            </div>
        </div>
    </div>

<div class="archive-banner" id="archiveBanner">
    üìÖ History Mode
</div>

<div class="game-container">
    <div class="result-display" id="resultDisplay"></div>
    <div class="hint-display" id="hintDisplay"></div>

```
<div class="diamond-grid" id="diamondGrid">
    <div class="slot top" id="slot0"></div>
    <div class="slot left" id="slot1"></div>
    <div class="slot right" id="slot2"></div>
    <div class="slot bottom" id="slot3"></div>
</div>
```

</div>

<div class="operators-overlay" id="operatorsOverlay">
    <div class="operators-grid">
        <button class="op-btn" data-op="+">+</button>
        <button class="op-btn" data-op="-">‚àí</button>
        <button class="op-btn" data-op="*">√ó</button>
        <button class="op-btn" data-op="/">√∑</button>
    </div>
</div>

<div class="move-dots" id="moveDots">
    <div class="move-dot perfect-hint"></div>
    <div class="move-dot perfect-hint"></div>
    <div class="move-dot perfect-hint"></div>
</div>

<div class="message" id="successMessage">
    <h2 id="successTitle">üéâ Nice!</h2>
    <p id="successSubtitle">You made 24!</p>
    <div class="difficulty-badge" id="difficultyBadge" style="display:none;"></div>
    <div class="stats" id="successStats"></div>
    <div class="percentile" id="percentileDisplay"></div>
    <div class="btn-row">
        <button class="btn btn-primary" id="shareBtn">Share</button>
        <button class="btn btn-challenge" id="challengeBtn">‚öîÔ∏è Challenge</button>
        <button class="btn btn-secondary" id="closeSuccessBtn">Close</button>
    </div>
</div>

<div class="modal-overlay" id="archiveModal">
    <div class="modal">
        <h2>üìÖ History</h2>
        <div class="archive-list" id="archiveList"></div>
        <button class="share-history-btn" id="shareHistoryBtn">üìä Share My Last 24 Days</button>
        <div class="sync-section" id="syncSection">
            <div class="sync-label" id="syncLabel">Keep your streak across devices</div>
            <div class="sync-methods" id="syncMethods">
                <button class="google-btn" id="googleSignInBtn">
                    <svg viewBox="0 0 24 24"><path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92a5.06 5.06 0 0 1-2.2 3.32v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.1z"/><path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/><path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/><path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/></svg>
                    Continue with Google
                </button>
                <div class="sync-divider">or use email code</div>
                <div class="email-otp-row" id="emailOtpRow">
                    <input type="email" class="email-otp-input" id="otpEmailInput" placeholder="your@email.com" autocomplete="email" autocapitalize="off">
                    <button class="email-send-btn" id="otpSendBtn">Send code</button>
                </div>
                <div class="otp-verify-row" id="otpVerifyRow">
                    <input type="text" class="otp-code-input" id="otpCodeInput" placeholder="6-digit code" maxlength="6" inputmode="numeric" autocomplete="one-time-code">
                    <button class="otp-verify-btn" id="otpVerifyBtn">Verify</button>
                </div>
                <div class="sync-status" id="syncStatus"></div>
            </div>
            <div id="syncSignedInView" style="display:none;">
                <button class="sync-signout" id="syncSignOutBtn">Sign out</button>
            </div>
        </div>
        <button class="modal-close" id="closeArchive">Close</button>
    </div>
</div>

<div class="sync-nudge" id="syncNudge">
    üî• Nice streak! <span class="sync-nudge-link" id="syncNudgeLink">Sign in</span> to keep it across devices.
    <span class="sync-nudge-dismiss" id="syncNudgeDismiss">‚úï</span>
</div>

<div class="confetti-container" id="confetti"></div>
<canvas class="share-canvas" id="shareCanvas"></canvas>

<script>
    // Prevent iOS overscroll artifacts
    document.addEventListener('touchmove', function(e) {
        if (e.target.closest('.archive-list') || e.target.closest('.modal')) return;
        e.preventDefault();
    }, { passive: false });

    document.body.addEventListener('touchmove', function(e) {
        if (e.target.closest('.archive-list') || e.target.closest('.modal')) return;
        e.preventDefault();
    }, { passive: false });

    // ============================================================
    // CONFIG (different per deployment)
    // ============================================================
    const APP_CONFIG = {
        publicUrl: 'https://make24.app/',
        shareLabel: 'make24.app'
    };

    // Supabase config
    const SUPABASE_URL = 'https://fimsbfcvavpehryvvcho.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpbXNiZmN2YXZwZWhyeXZ2Y2hvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzOTEwMDMsImV4cCI6MjA3MDk2NzAwM30.6uAm_bDPN9aetYaKWA7zCvS8XDEVhmKKxA7RA7YK4JQ';

    // Supabase client (auth-aware)
    const { createClient } = supabase;
    const sb = createClient(SUPABASE_URL, SUPABASE_KEY);

    // Constants
    const STORAGE_KEY = 'make24_v5';
    const ARCHIVE_DAYS = 30;
    const STREAK_FREEZE_INTERVAL = 7;
    const PERFECT_MOVES = 3;
    const HINT_DELAY_MS = 90000;
    const HISTORY_SHARE_DAYS = 24;

    // Game state
    let gameState = {
        deviceId: null,
        streak: 0,
        freezes: 0,
        lastPlayedDate: null,
        history: {},
    };

    let currentPuzzle = {
        numbers: [],
        puzzleNum: 0,
        date: null,
        isArchive: false
    };

    let playState = {
        cards: [],
        selected: [],
        moves: 0,
        cardStates: [],
        operatorHistory: [],
        undoCount: 0,
        startTime: null,
        endTime: null,
        completed: false,
        hinted: false,
    };

    // Hint system state
    let hintTimer = null;
    let hintVisible = false;

    // Valid solvable puzzles
    const VALID_PUZZLES = [[5,6,7,9],[1,6,8,9],[4,8,9,9],[1,5,8,9],[2,3,4,7],[1,7,8,8],[3,6,7,8],[4,6,6,7],[2,5,6,7],[1,3,3,4],[1,4,4,6],[1,1,6,9],[2,4,6,9],[1,5,6,7],[1,3,4,4],[1,1,5,8],[1,3,7,8],[2,4,4,6],[3,3,4,4],[2,3,5,8],[2,3,4,4],[1,1,3,4],[3,4,6,8],[1,3,8,8],[6,8,8,9],[6,6,6,6],[4,6,6,9],[4,5,5,8],[1,5,7,8],[1,1,6,6],[2,6,6,6],[1,4,8,8],[4,4,4,6],[1,2,6,9],[2,4,4,7],[5,5,9,9],[1,4,5,9],[5,5,5,6],[1,2,4,5],[2,2,2,7],[3,5,7,8],[2,5,5,8],[1,2,3,8],[3,4,5,7],[5,7,8,9],[1,4,6,8],[1,3,3,6],[2,2,2,9],[3,3,7,9],[3,3,6,7],[1,3,4,8],[1,1,4,4],[1,4,4,9],[2,2,3,4],[1,4,5,6],[1,2,5,9],[1,1,1,8],[2,3,3,9],[3,4,9,9],[2,5,8,9],[4,4,6,9],[2,2,7,8],[4,5,5,7],[3,6,6,6],[1,2,6,8],[2,6,6,7],[2,6,6,8],[1,2,5,6],[2,6,7,8],[2,4,6,7],[3,3,3,4],[5,5,5,9],[3,8,9,9],[3,4,4,7],[2,2,4,7],[3,7,7,8],[3,3,3,6],[3,6,7,9],[4,6,6,6],[1,2,6,7],[1,1,4,8],[3,4,6,9],[2,3,9,9],[2,2,3,8],[5,5,8,8],[1,1,8,8],[2,2,5,9],[3,3,3,9],[3,7,7,7],[3,3,6,8],[5,5,8,9],[4,6,9,9],[1,4,4,5],[4,4,5,5],[6,6,6,8],[3,7,8,8],[3,9,9,9],[2,5,6,8],[3,3,4,6],[6,6,7,9],[2,4,5,5],[1,5,8,8],[1,1,3,8],[2,2,3,5],[1,3,5,6],[1,6,6,8],[1,4,5,7],[2,4,5,8],[1,2,2,6],[2,4,7,7],[2,2,3,9],[3,3,3,5],[1,5,6,9],[2,2,5,6],[1,4,5,5],[2,8,9,9],[5,6,6,9],[3,5,8,9],[1,4,6,9],[2,5,7,8],[3,6,8,8],[4,5,5,9],[1,2,3,5],[3,4,7,9],[5,5,6,7],[2,4,6,8],[4,5,8,8],[4,7,7,7],[2,4,7,8],[1,2,5,5],[4,5,6,8],[3,6,7,7],[1,3,4,7],[2,3,4,8],[1,3,7,7],[2,3,4,5],[2,2,2,4],[1,3,3,5],[1,2,3,4],[2,2,6,8],[3,3,5,7],[1,2,4,9],[1,1,2,8],[5,6,6,8],[3,6,6,7],[1,3,8,9],[1,3,6,7],[1,1,2,6],[4,5,6,7],[1,2,5,7],[2,4,5,6],[2,4,7,9],[1,1,2,9],[6,8,8,8],[1,2,3,6],[1,1,5,7],[6,6,6,9],[3,7,9,9],[3,6,6,9],[3,6,6,8],[1,3,5,8],[2,3,6,9],[1,2,4,8],[2,3,5,7],[2,5,5,7],[3,3,9,9],[4,4,5,6],[2,2,5,7],[1,8,8,8],[2,4,5,7],[4,5,7,7],[1,6,9,9],[1,1,4,7],[1,7,8,9],[1,3,4,9],[3,3,5,5],[1,2,8,8],[5,6,9,9],[1,3,4,5],[6,8,9,9],[3,5,6,6],[2,2,4,9],[3,5,5,9],[4,4,8,8],[2,3,3,7],[4,4,4,8],[6,7,8,9],[1,3,6,6],[3,3,6,6],[4,4,7,9],[1,1,2,7],[4,7,7,8],[3,3,4,9],[1,6,6,9],[2,2,4,5],[1,2,8,9],[3,4,4,5],[1,5,9,9],[2,4,4,9],[2,3,3,5],[3,6,8,9],[2,4,6,6],[3,4,5,8],[3,3,4,5],[1,2,3,7],[2,2,6,9],[2,3,8,9],[2,3,7,7],[2,5,5,9],[1,2,6,6],[1,2,2,5],[5,8,8,8],[3,4,5,6],[1,4,5,8],[1,3,6,8],[4,6,6,8],[3,3,8,9],[2,2,3,6],[2,4,8,9],[3,3,7,8],[1,8,8,9],[4,5,7,9],[7,8,8,9],[5,8,8,9],[2,7,8,8],[1,4,4,7],[3,3,3,7],[3,5,8,8],[1,2,7,7],[1,3,3,9],[2,5,8,8],[1,2,4,7],[2,3,4,9],[2,7,8,9],[1,3,9,9],[2,2,5,8],[3,3,3,8],[3,7,7,9],[4,5,8,9],[5,6,8,8],[2,3,3,3],[1,2,5,8],[2,3,5,9],[1,2,2,7],[1,4,6,6],[3,8,8,8],[4,5,9,9],[3,5,5,6],[1,4,6,7],[3,3,7,7],[4,4,5,8],[1,1,3,5],[1,1,5,5],[1,2,3,3],[1,5,5,6],[1,6,8,8],[1,3,5,7],[1,3,7,9],[2,2,4,4],[1,6,6,6],[3,3,8,8],[1,1,4,9],[1,2,3,9],[2,5,6,6],[5,5,6,8],[3,5,6,8],[4,4,4,9],[2,7,7,8],[3,5,5,8],[4,5,7,8],[2,3,7,8],[2,3,8,8],[3,4,6,6],[3,4,4,6],[4,4,4,5],[4,6,8,9],[2,3,7,9],[3,8,8,9],[4,4,7,8],[1,4,7,9],[4,6,8,8],[2,2,4,6],[6,6,8,9],[3,3,4,7],[5,6,7,8],[1,5,5,9],[1,1,3,6],[4,6,7,9],[3,6,9,9],[4,7,8,8],[2,2,2,8],[1,2,7,8],[4,4,4,4],[2,4,4,5],[4,8,8,9],[2,5,6,9],[1,4,7,8],[4,6,7,7],[2,3,4,6],[5,5,7,7],[1,1,3,7],[2,2,6,6],[3,3,5,6],[5,5,6,6],[4,6,7,8],[2,2,8,9],[2,4,4,8],[4,7,8,9],[1,2,2,4],[2,3,6,6],[4,4,7,7],[3,5,7,9],[3,4,4,9],[2,4,5,9],[1,5,7,9],[2,6,6,9],[6,6,8,8],[2,2,8,8],[1,4,4,4],[4,5,6,6],[4,4,8,9],[3,7,8,9],[3,4,7,8],[3,5,9,9],[6,7,9,9],[1,7,7,9],[3,4,4,8],[3,4,4,4],[5,7,8,8],[3,5,5,7],[2,5,7,7],[1,3,6,9],[2,2,6,7],[5,5,5,5],[3,3,4,8],[4,7,9,9],[5,6,7,7],[2,8,8,9],[3,4,8,9],[3,3,3,3],[1,4,7,7],[2,3,6,8],[1,5,6,8],[1,4,4,8],[2,2,5,5],[3,3,5,9],[2,5,7,9],[2,4,8,8],[2,2,2,5],[2,4,4,4],[2,6,8,9],[1,7,9,9],[1,3,5,9],[2,3,3,6],[2,6,9,9],[4,4,6,8],[2,3,5,5],[2,2,7,7],[3,5,6,9],[2,6,8,8],[2,3,5,6],[4,5,5,6],[1,3,3,7],[5,6,6,7],[5,5,7,8],[5,6,6,6],[1,2,4,4],[1,4,8,9],[4,5,5,5],[2,3,6,7],[2,2,3,3],[1,1,4,6],[4,4,4,7],[2,3,3,8],[3,4,5,5],[2,4,9,9],[2,2,3,7],[4,5,6,9],[1,5,6,6],[1,1,3,9],[2,2,4,8],[3,3,6,9],[3,4,7,7],[2,8,8,8],[1,1,6,8],[1,6,7,9],[5,7,7,9],[3,5,6,7],[2,2,2,3],[1,5,5,5],[1,2,2,8],[1,2,2,9],[4,4,5,7],[1,3,3,3],[1,3,4,6],[1,2,7,9],[3,4,5,9],[2,6,7,9],[1,1,5,6],[1,1,4,5],[1,3,3,8],[4,8,8,8],[1,2,4,6],[5,6,8,9]];

    // ============================================================
    // DIFFICULTY SCORING ENGINE
    // ============================================================
    function evaluateAllExpressions(a, b, c, d) {
        const ops = ['+', '-', '*', '/'];
        const nums = [a, b, c, d];
        const perms = [];
        for (let i = 0; i < 4; i++)
            for (let j = 0; j < 4; j++) if (j !== i)
                for (let k = 0; k < 4; k++) if (k !== i && k !== j)
                    for (let l = 0; l < 4; l++) if (l !== i && l !== j && l !== k)
                        perms.push([nums[i], nums[j], nums[k], nums[l]]);

        let solutionCount = 0;
        let hasDivision = false;
        let hasNonInteger = false;

        for (const perm of perms) {
            const [w, x, y, z] = perm;
            for (const o1 of ops) for (const o2 of ops) for (const o3 of ops) {
                const r1 = calc(w, o1, x);
                if (r1 === null) continue;
                const r2 = calc(r1, o2, y);
                if (r2 === null) continue;
                const r3 = calc(r2, o3, z);
                if (r3 !== null && Math.abs(r3 - 24) < 0.0001) {
                    solutionCount++;
                    if (o1 === '/' || o2 === '/' || o3 === '/') hasDivision = true;
                    if (!Number.isInteger(r1) || !Number.isInteger(r2)) hasNonInteger = true;
                }

                const s1 = calc(w, o1, x);
                if (s1 === null) continue;
                const s2 = calc(y, o2, z);
                if (s2 === null) continue;
                const s3 = calc(s1, o3, s2);
                if (s3 !== null && Math.abs(s3 - 24) < 0.0001) {
                    solutionCount++;
                    if (o1 === '/' || o2 === '/' || o3 === '/') hasDivision = true;
                    if (!Number.isInteger(s1) || !Number.isInteger(s2)) hasNonInteger = true;
                }
            }
        }
        return { solutionCount, hasDivision, hasNonInteger };
    }

    function calc(a, op, b) {
        switch (op) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return b === 0 ? null : a / b;
        }
    }

    function getPuzzleDifficulty(numbers) {
        const result = evaluateAllExpressions(...numbers);
        if (result.solutionCount >= 20) return { level: 'easy', label: 'Easy', emoji: 'üß©' };
        if (result.solutionCount >= 6) return { level: 'medium', label: 'Medium', emoji: 'üß©üß©' };
        return { level: 'hard', label: 'Hard', emoji: 'üß©üß©üß©' };
    }

    const difficultyCache = {};
    function getCachedDifficulty(puzzleNum) {
        if (!difficultyCache[puzzleNum]) {
            const nums = generatePuzzle(puzzleNum);
            difficultyCache[puzzleNum] = getPuzzleDifficulty(nums);
        }
        return difficultyCache[puzzleNum];
    }

    // ============================================================
    // HINT SYSTEM
    // ============================================================
    function findHintForPuzzle(numbers) {
        const ops = ['+', '-', '*', '/'];
        const opSymbols = { '+': '+', '-': '‚àí', '*': '√ó', '/': '√∑' };
        for (let i = 0; i < 4; i++) {
            for (let j = i + 1; j < 4; j++) {
                for (const op of ops) {
                    const orderings = (op === '+' || op === '*') ?
                        [[numbers[i], numbers[j]]] :
                        [[numbers[i], numbers[j]], [numbers[j], numbers[i]]];

                    for (const [a, b] of orderings) {
                        const r = calc(a, op, b);
                        if (r === null) continue;
                        const remaining = numbers.filter((_, idx) => idx !== i && idx !== j);
                        remaining.push(r);
                        if (canMake24From3(remaining)) {
                            return `Try ${a} ${opSymbols[op]} ${b}`;
                        }
                    }
                }
            }
        }
        return null;
    }

    function canMake24From3(nums) {
        const ops = ['+', '-', '*', '/'];
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) if (j !== i) {
                for (let k = 0; k < 3; k++) if (k !== i && k !== j) {
                    const [a, b, c] = [nums[i], nums[j], nums[k]];
                    for (const o1 of ops) for (const o2 of ops) {
                        const r1 = calc(a, o1, b);
                        if (r1 !== null) {
                            const r2 = calc(r1, o2, c);
                            if (r2 !== null && Math.abs(r2 - 24) < 0.0001) return true;
                        }
                        const s1 = calc(b, o2, c);
                        if (s1 !== null) {
                            const s2 = calc(a, o1, s1);
                            if (s2 !== null && Math.abs(s2 - 24) < 0.0001) return true;
                        }
                    }
                }
            }
        }
        return false;
    }

    function startHintTimer() {
        clearHintTimer();
        hintVisible = false;
        document.getElementById('hintBtn').classList.remove('visible');
        document.getElementById('hintDisplay').classList.remove('visible');
        document.getElementById('hintDisplay').textContent = '';
        if (playState.completed) return;
        hintTimer = setTimeout(() => {
            if (!playState.completed && playState.moves === 0) {
                document.getElementById('hintBtn').classList.add('visible');
                hintVisible = true;
            }
        }, HINT_DELAY_MS);
    }

    function clearHintTimer() {
        if (hintTimer) { clearTimeout(hintTimer); hintTimer = null; }
    }

    function useHint() {
        if (playState.completed || playState.hinted) return;
        const remaining = playState.cards.filter(c => !c.used).map(c => c.value);
        let hintText;
        if (remaining.length === 4) {
            hintText = findHintForPuzzle(remaining);
        } else {
            hintText = null;
        }
        if (hintText) {
            playState.hinted = true;
            document.getElementById('hintDisplay').textContent = hintText;
            document.getElementById('hintDisplay').classList.add('visible');
            document.getElementById('hintBtn').classList.remove('visible');
            clearHintTimer();
        }
    }

    // ============================================================
    // AUTH ‚Äî guest-first, Google + email OTP code
    // ============================================================
    const NUDGE_DISMISSED_KEY = 'make24_sync_nudge_dismissed';
    const STREAK_NUDGE_MILESTONES = [3, 7, 14];
    let pendingOtpEmail = null;

    async function updateSyncUI() {
        const syncSection = document.getElementById('syncSection');
        const syncLabel = document.getElementById('syncLabel');
        const syncMethods = document.getElementById('syncMethods');
        const signedInView = document.getElementById('syncSignedInView');
        const syncStatus = document.getElementById('syncStatus');
        if (!syncSection) return;

        const { data: { session } } = await sb.auth.getSession();
        const email = session?.user?.email;

        if (email) {
            syncSection.classList.add('signed-in');
            syncLabel.textContent = `Synced as ${email}`;
            syncMethods.style.display = 'none';
            signedInView.style.display = 'block';
            syncStatus.textContent = '';
            syncStatus.className = 'sync-status';
        } else {
            syncSection.classList.remove('signed-in');
            syncLabel.textContent = 'Keep your streak across devices';
            syncMethods.style.display = 'flex';
            signedInView.style.display = 'none';
            // Reset OTP UI
            document.getElementById('emailOtpRow').style.display = 'flex';
            document.getElementById('otpVerifyRow').classList.remove('visible');
            document.getElementById('otpEmailInput').value = '';
            document.getElementById('otpCodeInput').value = '';
            pendingOtpEmail = null;
        }
    }

    // Google sign-in via popup (stays in PWA context)
    async function signInWithGoogle() {
        const status = document.getElementById('syncStatus');
        status.textContent = 'Opening Google sign-in...';
        status.className = 'sync-status';

        const { error } = await sb.auth.signInWithOAuth({
            provider: 'google',
            options: {
                redirectTo: window.location.href,
                queryParams: { prompt: 'select_account' }
            }
        });

        if (error) {
            status.textContent = error.message;
            status.className = 'sync-status error';
        }
    }

    // Email OTP: send code
    async function sendOtpCode() {
        const emailInput = document.getElementById('otpEmailInput');
        const email = emailInput.value.trim();
        if (!email || !email.includes('@')) {
            const status = document.getElementById('syncStatus');
            status.textContent = 'Please enter a valid email.';
            status.className = 'sync-status error';
            return;
        }

        const sendBtn = document.getElementById('otpSendBtn');
        sendBtn.disabled = true;
        sendBtn.textContent = 'Sending...';

        const status = document.getElementById('syncStatus');
        status.textContent = '';
        status.className = 'sync-status';

        const { error } = await sb.auth.signInWithOtp({
            email,
            options: {
                shouldCreateUser: true
            }
        });

        if (error) {
            status.textContent = error.message;
            status.className = 'sync-status error';
            sendBtn.disabled = false;
            sendBtn.textContent = 'Send code';
            return;
        }

        pendingOtpEmail = email;
        status.textContent = 'Code sent! Check your email (and spam).';
        status.className = 'sync-status success';

        // Show code entry row, hide email row
        document.getElementById('emailOtpRow').style.display = 'none';
        document.getElementById('otpVerifyRow').classList.add('visible');
        document.getElementById('otpCodeInput').focus();

        sendBtn.disabled = false;
        sendBtn.textContent = 'Send code';
    }

    // Email OTP: verify code
    async function verifyOtpCode() {
        const codeInput = document.getElementById('otpCodeInput');
        const code = codeInput.value.trim();
        const status = document.getElementById('syncStatus');

        if (!code || code.length < 6) {
            status.textContent = 'Enter the 6-digit code from your email.';
            status.className = 'sync-status error';
            return;
        }

        if (!pendingOtpEmail) {
            status.textContent = 'Session expired. Please send a new code.';
            status.className = 'sync-status error';
            document.getElementById('emailOtpRow').style.display = 'flex';
            document.getElementById('otpVerifyRow').classList.remove('visible');
            return;
        }

        const verifyBtn = document.getElementById('otpVerifyBtn');
        verifyBtn.disabled = true;
        verifyBtn.textContent = '...';

        const { error } = await sb.auth.verifyOtp({
            email: pendingOtpEmail,
            token: code,
            type: 'email'
        });

        verifyBtn.disabled = false;
        verifyBtn.textContent = 'Verify';

        if (error) {
            status.textContent = error.message;
            status.className = 'sync-status error';
        }
        // Success is handled by onAuthStateChange listener
    }

    async function promptSignOut() {
        const ok = confirm('Sign out? (Your local history stays on this device.)');
        if (!ok) return;
        const { error } = await sb.auth.signOut();
        if (error) alert('Sign-out failed: ' + error.message);
        await updateSyncUI();
    }

    // Nudge: gentle toast at streak milestones
    async function maybeShowSyncNudge() {
        const { data: { session } } = await sb.auth.getSession();
        if (session) return;

        const dismissed = localStorage.getItem(NUDGE_DISMISSED_KEY);
        if (dismissed === 'forever') return;

        const streak = gameState.streak;
        if (!STREAK_NUDGE_MILESTONES.includes(streak)) return;

        const shownKey = `make24_nudge_shown_${streak}`;
        if (localStorage.getItem(shownKey)) return;
        localStorage.setItem(shownKey, '1');

        const nudge = document.getElementById('syncNudge');
        setTimeout(() => nudge.classList.add('visible'), 1200);
        setTimeout(() => nudge.classList.remove('visible'), 8000);
    }

    function dismissSyncNudge() {
        const nudge = document.getElementById('syncNudge');
        nudge.classList.remove('visible');
        localStorage.setItem(NUDGE_DISMISSED_KEY, 'forever');
    }

    // Nudge link opens the archive modal (where the sign-in lives)
    function nudgeOpenSignIn() {
        dismissSyncNudge();
        showArchive();
        // Scroll sync section into view after modal opens
        setTimeout(() => {
            const syncSection = document.getElementById('syncSection');
            if (syncSection) syncSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }, 300);
    }

    async function ensureCanonicalDeviceId() {
        const { data: { session } } = await sb.auth.getSession();
        if (!session) return;
        const localId = getDeviceId();
        try {
            const { data, error } = await sb.rpc('get_or_set_device_id', { p_device_id: localId });
            if (error) { console.log('get_or_set_device_id error:', error.message); return; }
            const canonicalId = data;
            if (canonicalId && canonicalId !== localId) {
                localStorage.setItem('make24_device_id', canonicalId);
                gameState.deviceId = canonicalId;
                saveState();
            }
        } catch (e) { console.log('ensureCanonicalDeviceId skipped:', e); }
    }

    async function syncFromSupabase() {
        try {
            const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/get_or_create_player`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_KEY,
                    'Authorization': `Bearer ${SUPABASE_KEY}`
                },
                body: JSON.stringify({ p_device_id: gameState.deviceId })
            });
            if (!response.ok) return;
            const player = await response.json();
            const serverStreak = Number(player?.current_streak ?? player?.streak ?? 0);
            const serverFreezes = Number(player?.freezes ?? 0);
            const localStreak = Number(gameState.streak ?? 0);
            if (localStreak === 0 || (Number.isFinite(serverStreak) && serverStreak > localStreak)) {
                gameState.streak = serverStreak;
                gameState.freezes = serverFreezes;
                saveState();
            }
            updateStreakDisplay();
        } catch (e) { console.log('syncFromSupabase skipped:', e?.message || e); }
    }

    async function syncHistoryFromSupabase() {
        try {
            // Step 1: Get player_id from device_id
            const playerUrl = `${SUPABASE_URL}/rest/v1/players?device_id=eq.${encodeURIComponent(gameState.deviceId)}&select=id&limit=1`;
            const playerRes = await fetch(playerUrl, {
                headers: {
                    'apikey': SUPABASE_KEY,
                    'Authorization': `Bearer ${SUPABASE_KEY}`
                }
            });
            if (!playerRes.ok) return;
            const players = await playerRes.json();
            if (!players || players.length === 0) return;
            const playerId = players[0].id;

            // Step 2: Get all solved puzzles from daily_results
            const url = `${SUPABASE_URL}/rest/v1/daily_results?player_id=eq.${playerId}&solved=eq.true&select=puzzle_num,moves,solve_time_seconds,operators,undos,is_perfect,is_fast&order=puzzle_num.desc&limit=500`;
            const response = await fetch(url, {
                headers: {
                    'apikey': SUPABASE_KEY,
                    'Authorization': `Bearer ${SUPABASE_KEY}`
                }
            });
            if (!response.ok) return;
            const rows = await response.json();
            if (!rows || rows.length === 0) return;

            let merged = 0;
            for (const row of rows) {
                const num = row.puzzle_num;
                const existing = gameState.history[num];
                // Only fill in missing history ‚Äî never overwrite local data
                if (!existing || !existing.completed) {
                    gameState.history[num] = {
                        completed: true,
                        moves: row.moves || 0,
                        operators: row.operators || [],
                        undos: row.undos || 0,
                        solveTime: row.solve_time_seconds || 0,
                        hinted: false
                    };
                    merged++;
                }
            }
            if (merged > 0) {
                saveState();
                console.log(`History sync: merged ${merged} solves from server`);
            }
        } catch (e) { console.log('syncHistoryFromSupabase skipped:', e?.message || e); }
    }

    sb.auth.onAuthStateChange(async (_event, session) => {
        await updateSyncUI();
        if (session) {
            await ensureCanonicalDeviceId();
            await syncFromSupabase();
            await syncHistoryFromSupabase();
            updateStreakDisplay();
        }
    });

    // ============================================================
    // SHAREABLE HISTORY GRID
    // ============================================================
    function generateHistoryImage() {
        const canvas = document.getElementById('shareCanvas');
        const ctx = canvas.getContext('2d');
        const today = getTodayPuzzleNumber();
        const days = HISTORY_SHARE_DAYS;
        const cols = 6;
        const rows = Math.ceil(days / cols);
        const cellSize = 48;
        const gap = 6;
        const padding = 24;
        const headerHeight = 60;
        const footerHeight = 44;
        const gridWidth = cols * cellSize + (cols - 1) * gap;
        const gridHeight = rows * cellSize + (rows - 1) * gap;

        canvas.width = gridWidth + padding * 2;
        canvas.height = headerHeight + gridHeight + footerHeight + padding;

        ctx.fillStyle = '#0f172a';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = '#22d3ee';
        ctx.font = 'bold 18px "Space Mono", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`Make 24 ‚Äî Last ${days} Days`, canvas.width / 2, 36);

        ctx.fillStyle = '#f1f5f9';
        ctx.font = '14px "DM Sans", sans-serif';
        ctx.fillText(`üî• ${gameState.streak} streak`, canvas.width / 2, 54);

        for (let i = 0; i < days; i++) {
            const num = today - i;
            if (num < 1) continue;
            const col = i % cols;
            const row = Math.floor(i / cols);
            const x = padding + col * (cellSize + gap);
            const y = headerHeight + row * (cellSize + gap);

            const history = gameState.history[num];
            const completed = history?.completed;
            const isPerfect = completed && history.moves === PERFECT_MOVES && (history.undos || 0) === 0;
            const isFast = isPerfect && history.solveTime && history.solveTime <= 60;

            if (isFast) ctx.fillStyle = 'rgba(251, 191, 36, 0.5)';
            else if (isPerfect) ctx.fillStyle = 'rgba(251, 191, 36, 0.25)';
            else if (completed) ctx.fillStyle = 'rgba(16, 185, 129, 0.3)';
            else ctx.fillStyle = '#1e293b';

            const r = 6;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + cellSize - r, y);
            ctx.quadraticCurveTo(x + cellSize, y, x + cellSize, y + r);
            ctx.lineTo(x + cellSize, y + cellSize - r);
            ctx.quadraticCurveTo(x + cellSize, y + cellSize, x + cellSize - r, y + cellSize);
            ctx.lineTo(x + r, y + cellSize);
            ctx.quadraticCurveTo(x, y + cellSize, x, y + cellSize - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
            ctx.fill();

            if (num === today) { ctx.strokeStyle = '#22d3ee'; ctx.lineWidth = 2; }
            else if (isFast || isPerfect) { ctx.strokeStyle = '#fbbf24'; ctx.lineWidth = 1.5; }
            else if (completed) { ctx.strokeStyle = '#10b981'; ctx.lineWidth = 1; }
            else { ctx.strokeStyle = '#334155'; ctx.lineWidth = 1; }
            ctx.stroke();

            ctx.fillStyle = '#f1f5f9';
            ctx.font = 'bold 13px "Space Mono", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(num.toString(), x + cellSize / 2, y + cellSize / 2);

            if (isFast) { ctx.font = '10px sans-serif'; ctx.fillText('‚≠ê‚≠ê', x + cellSize - 8, y + 8); }
            else if (isPerfect) { ctx.font = '10px sans-serif'; ctx.fillText('‚≠ê', x + cellSize - 6, y + 8); }
        }

        ctx.fillStyle = '#64748b';
        ctx.font = '12px "DM Sans", sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillText(APP_CONFIG.shareLabel, canvas.width / 2, headerHeight + gridHeight + 16);

        return canvas;
    }

    function shareHistoryGrid() {
        const canvas = generateHistoryImage();
        const today = getTodayPuzzleNumber();
        let solved = 0, perfect = 0, fastPerfect = 0;
        for (let i = 0; i < HISTORY_SHARE_DAYS; i++) {
            const num = today - i;
            const h = gameState.history[num];
            if (h?.completed) {
                solved++;
                const ip = h.moves === PERFECT_MOVES && (h.undos || 0) === 0;
                if (ip && h.solveTime && h.solveTime <= 60) fastPerfect++;
                else if (ip) perfect++;
            }
        }

        let emojiGrid = '';
        for (let i = 0; i < HISTORY_SHARE_DAYS; i++) {
            const num = today - i;
            const h = gameState.history[num];
            if (!h?.completed) emojiGrid += '‚¨õ';
            else {
                const ip = h.moves === PERFECT_MOVES && (h.undos || 0) === 0;
                const fast = ip && h.solveTime && h.solveTime <= 60;
                if (fast) emojiGrid += 'üåü';
                else if (ip) emojiGrid += '‚≠ê';
                else emojiGrid += 'üü©';
            }
            if ((i + 1) % 6 === 0 && i < HISTORY_SHARE_DAYS - 1) emojiGrid += '\n';
        }

        const shareText = `Make 24 ‚Äî Last ${HISTORY_SHARE_DAYS} Days\n${emojiGrid}\nüî• ${gameState.streak} | ${solved}/${HISTORY_SHARE_DAYS} solved\n${APP_CONFIG.publicUrl}`;

        canvas.toBlob(async (blob) => {
            if (blob && navigator.share && navigator.canShare) {
                const file = new File([blob], 'make24-history.png', { type: 'image/png' });
                const shareData = { text: shareText, files: [file] };
                try {
                    if (navigator.canShare(shareData)) { await navigator.share(shareData); return; }
                } catch (e) { /* fall through */ }
            }
            if (navigator.share) {
                navigator.share({ text: shareText }).catch(() => copyToClipboard(shareText));
            } else { copyToClipboard(shareText); }
        }, 'image/png');
    }

    // ============================================================
    // CHALLENGE A FRIEND
    // ============================================================
    function shareChallenge() {
        const puzzleNum = currentPuzzle.puzzleNum;
        const history = gameState.history[puzzleNum];
        const moves = history?.moves || playState.moves;
        const isPerfect = history?.completed && history.moves === PERFECT_MOVES && (history.undos || 0) === 0;

        let text = `‚öîÔ∏è Can you beat my Make 24?\n`;
        text += `Puzzle #${puzzleNum}`;
        if (isPerfect) text += ` ‚Äî I got ‚≠ê Perfect`;
        else text += ` ‚Äî I solved it in ${moves} moves`;
        text += `\n\n${APP_CONFIG.publicUrl}`;

        if (navigator.share) {
            navigator.share({ text }).catch(() => copyToClipboard(text));
        } else { copyToClipboard(text); }
    }

    // ============================================================
    // CORE GAME ENGINE
    // ============================================================
    function mulberry32(seed) {
        return function() {
            let t = seed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
    }

    function getPuzzleNumber(date) {
        const epoch = new Date('2025-01-01T00:00:00Z');
        const diff = date - epoch;
        return Math.floor(diff / (24 * 60 * 60 * 1000)) + 1;
    }

    function getDateFromPuzzleNumber(num) {
        const epoch = new Date('2025-01-01T00:00:00Z');
        return new Date(epoch.getTime() + (num - 1) * 24 * 60 * 60 * 1000);
    }

    function getTodayPuzzleNumber() {
        const now = new Date();
        const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
        return getPuzzleNumber(utcDate);
    }

    function generatePuzzle(puzzleNum) {
        const puzzleIndex = (puzzleNum - 1) % VALID_PUZZLES.length;
        const basePuzzle = VALID_PUZZLES[puzzleIndex];
        const rng = mulberry32(puzzleNum * 12345);
        const shuffled = [...basePuzzle];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(rng() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        return shuffled;
    }

    function getDeviceId() {
        let id = localStorage.getItem('make24_device_id');
        if (!id) {
            id = 'dev_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
            localStorage.setItem('make24_device_id', id);
        }
        return id;
    }

    function loadState() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) gameState = { ...gameState, ...JSON.parse(saved) };
        } catch (e) { console.error('Failed to load state:', e); }
        gameState.deviceId = getDeviceId();
    }

    function saveState() {
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(gameState)); }
        catch (e) { console.error('Failed to save state:', e); }
    }

    function updateStreak() {
        const today = getTodayPuzzleNumber();
        const yesterday = today - 1;
        if (gameState.lastPlayedDate === today) return;
        if (gameState.lastPlayedDate === yesterday) { /* continues */ }
        else if (gameState.lastPlayedDate === yesterday - 1 && gameState.freezes > 0) {
            gameState.freezes--; saveState();
        } else if (gameState.lastPlayedDate && gameState.lastPlayedDate < yesterday) {
            gameState.streak = 0; saveState();
        }
        updateStreakDisplay();
    }

    function incrementStreak() {
        gameState.streak++;
        gameState.lastPlayedDate = currentPuzzle.puzzleNum;
        if (gameState.streak > 0 && gameState.streak % STREAK_FREEZE_INTERVAL === 0) gameState.freezes++;
        saveState();
        updateStreakDisplay();
    }

    function updateStreakDisplay() {
        document.getElementById('streakCount').textContent = gameState.streak;
        const freezeEl = document.getElementById('freezeIndicator');
        freezeEl.textContent = gameState.freezes > 0 ? '‚ùÑÔ∏è'.repeat(Math.min(gameState.freezes, 3)) : '';
    }

    function canUpgradeResult(puzzleNum) {
        const today = getTodayPuzzleNumber();
        if (puzzleNum === today) return true;
        const history = gameState.history[puzzleNum];
        if (history?.completed) return false;
        return true;
    }

    // ============================================================
    // CLEAN WIN SCREEN: fade cards, show big 24
    // ============================================================
    function showCleanWinState() {
        const grid = document.getElementById('diamondGrid');
        grid.classList.add('win-hidden');
        const display = document.getElementById('resultDisplay');
        display.textContent = '24';
        display.className = 'result-display win-clean';
    }

    function clearWinState() {
        const grid = document.getElementById('diamondGrid');
        grid.classList.remove('win-hidden');
        const display = document.getElementById('resultDisplay');
        display.className = 'result-display';
        display.textContent = '';
    }

    function initPuzzle(puzzleNum, isArchive = false) {
        document.getElementById('successMessage').classList.remove('show');
        hideOperators();
        clearHintTimer();
        clearWinState();

        currentPuzzle.puzzleNum = puzzleNum;
        currentPuzzle.numbers = generatePuzzle(puzzleNum);
        currentPuzzle.isArchive = isArchive;
        currentPuzzle.date = getDateFromPuzzleNumber(puzzleNum);

        const history = gameState.history[puzzleNum];
        const alreadySolved = history?.completed;

        // Locked archive puzzle
        if (alreadySolved && isArchive) {
            playState.completed = true;
            playState.moves = history.moves || 0;
            playState.operatorHistory = history.operators || [];
            playState.undoCount = history.undos || 0;
            playState.hinted = false;

            resetPlay();
            updateUI();
            showCleanWinState();

            const isPerfect = history.moves === PERFECT_MOVES && (history.undos || 0) === 0;
            const isFast = isPerfect && history.solveTime && history.solveTime <= 60;

            const title = document.getElementById('successTitle');
            const subtitle = document.getElementById('successSubtitle');
            const stats = document.getElementById('successStats');

            if (isFast) {
                title.textContent = '‚ö° Perfect + Fast!';
                title.classList.add('perfect');
                subtitle.textContent = `Solved in ${history.solveTime}s!`;
            } else if (isPerfect) {
                title.textContent = '‚≠ê Perfect!';
                title.classList.add('perfect');
                subtitle.textContent = 'Solved in just 3 moves!';
            } else {
                title.textContent = 'üéâ Already Solved';
                title.classList.remove('perfect');
                subtitle.textContent = `Completed in ${history.moves} moves`;
            }

            stats.innerHTML = `Moves: ${history.moves}`;
            showDifficultyBadge(puzzleNum);
            document.getElementById('percentileDisplay').textContent = 'üîí History is locked';

            setTimeout(() => {
                document.getElementById('successMessage').classList.add('show');
            }, 300);
            return;
        }

        // Today's puzzle already solved
        if (alreadySolved && !isArchive) {
            playState.completed = true;
            playState.moves = history.moves || 0;
            playState.operatorHistory = history.operators || [];
            playState.undoCount = history.undos || 0;
            playState.hinted = false;
        } else {
            playState.moves = 0;
            playState.completed = false;
            playState.operatorHistory = [];
            playState.undoCount = 0;
            playState.hinted = false;
        }

        resetPlay();
        updateUI();

        if (alreadySolved && !isArchive) {
            showCleanWinState();

            const isPerfect = history.moves === PERFECT_MOVES && (history.undos || 0) === 0;
            const isFast = isPerfect && history.solveTime && history.solveTime <= 60;

            const title = document.getElementById('successTitle');
            const subtitle = document.getElementById('successSubtitle');
            const stats = document.getElementById('successStats');

            if (isFast) {
                title.textContent = '‚ö° Perfect + Fast!';
                title.classList.add('perfect');
                subtitle.textContent = `Solved in ${history.solveTime}s!`;
            } else if (isPerfect) {
                title.textContent = '‚≠ê Perfect!';
                title.classList.add('perfect');
                subtitle.textContent = 'Solved in just 3 moves!';
            } else {
                title.textContent = 'üéâ Nice!';
                title.classList.remove('perfect');
                subtitle.textContent = 'You made 24!';
            }

            stats.innerHTML = `Moves: ${history.moves}`;
            showDifficultyBadge(puzzleNum);
            document.getElementById('percentileDisplay').textContent = '';

            setTimeout(() => {
                document.getElementById('successMessage').classList.add('show');
            }, 300);
        } else if (!alreadySolved) {
            startHintTimer();
        }
    }

    function showDifficultyBadge(puzzleNum) {
        const badge = document.getElementById('difficultyBadge');
        const diff = getCachedDifficulty(puzzleNum);
        badge.textContent = `${diff.emoji} ${diff.label}`;
        badge.className = 'difficulty-badge';
        badge.style.display = 'inline-block';
    }

    function hideDifficultyBadge() {
        document.getElementById('difficultyBadge').style.display = 'none';
    }

    function resetPlay() {
        playState.cards = currentPuzzle.numbers.map((v, i) => ({
            value: v, used: false, slot: i
        }));
        playState.selected = [];
        playState.cardStates = [];
        playState.operatorHistory = [];
        playState.undoCount = 0;
        playState.startTime = null;
        playState.endTime = null;

        document.getElementById('hintDisplay').classList.remove('visible');
        document.getElementById('hintDisplay').textContent = '';
        document.getElementById('hintBtn').classList.remove('visible');

        renderCards();
        hideOperators();
        updateResult();

        if (!playState.completed) {
            playState.startTime = Date.now();
        }
    }

    function renderCards() {
        const slots = ['slot0', 'slot1', 'slot2', 'slot3'];
        slots.forEach((slotId, i) => {
            const slot = document.getElementById(slotId);
            slot.innerHTML = '';
            const cardData = playState.cards.find(c => c.slot === i && !c.used);
            if (cardData) {
                const card = document.createElement('div');
                card.className = 'card';
                card.textContent = formatNumber(cardData.value);
                card.dataset.index = playState.cards.indexOf(cardData);
                const cardIndex = playState.cards.indexOf(cardData);
                if (playState.selected.includes(cardIndex)) {
                    card.classList.add('selected');
                    if (playState.selected[0] === cardIndex) card.classList.add('first');
                    else card.classList.add('second');
                }
                card.addEventListener('click', () => selectCard(cardIndex));
                slot.appendChild(card);
            }
        });
    }

    function formatNumber(n) {
        if (Number.isInteger(n)) return n.toString();
        const rounded = Math.round(n * 100) / 100;
        if (Number.isInteger(rounded)) return rounded.toString();
        return rounded.toFixed(2).replace(/\.?0+$/, '');
    }

    function selectCard(index) {
        if (playState.completed) return;
        if (playState.cards[index].used) return;

        const pos = playState.selected.indexOf(index);
        if (pos !== -1) {
            playState.selected.splice(pos, 1);
            hideOperators();
        } else if (playState.selected.length < 2) {
            playState.selected.push(index);
            if (playState.selected.length === 2) showOperators();
        }

        renderCards();
        maybeRequestMotion();
    }

    function showOperators() { document.getElementById('operatorsOverlay').classList.add('show'); }
    function hideOperators() { document.getElementById('operatorsOverlay').classList.remove('show'); }

    function applyOperation(op) {
        if (playState.selected.length !== 2 || playState.completed) return;

        const [i, j] = playState.selected;
        const a = playState.cards[i].value;
        const b = playState.cards[j].value;

        let result;
        switch (op) {
            case '+': result = a + b; break;
            case '-': result = a - b; break;
            case '*': result = a * b; break;
            case '/':
                if (b === 0) return;
                result = a / b;
                break;
        }

        if (!playState.startTime) playState.startTime = Date.now();

        document.getElementById('hintDisplay').classList.remove('visible');
        document.getElementById('hintBtn').classList.remove('visible');
        clearHintTimer();

        playState.cardStates.push({
            cards: JSON.parse(JSON.stringify(playState.cards)),
            operators: [...playState.operatorHistory]
        });

        playState.operatorHistory.push(op);
        playState.cards[i].used = true;
        playState.cards[j].used = true;

        const emptySlot = playState.cards[i].slot;
        playState.cards.push({ value: result, used: false, slot: emptySlot });

        playState.selected = [];
        playState.moves++;

        hideOperators();
        renderCards();
        updateResult();
        updateMoveDots();
        checkGameState();
    }

    function undo() {
        if (playState.cardStates.length === 0 || playState.completed) return;

        const prevState = playState.cardStates.pop();
        playState.cards = prevState.cards;
        playState.operatorHistory = prevState.operators;
        playState.selected = [];
        playState.moves++;
        playState.undoCount++;

        hideOperators();
        renderCards();
        updateResult();
        updateMoveDots();
    }

    function updateResult() {
        const remaining = playState.cards.filter(c => !c.used);
        const display = document.getElementById('resultDisplay');
        if (remaining.length === 1) {
            const val = remaining[0].value;
            display.textContent = formatNumber(val);
            display.classList.add('visible');
            if (Math.abs(val - 24) < 0.0001) {
                display.classList.add('success');
                display.classList.remove('error');
            } else {
                display.classList.remove('success');
                display.classList.add('error');
            }
        } else {
            display.textContent = '';
            display.classList.remove('visible', 'success', 'error');
        }
        updateUndoButton();
    }

    function updateUndoButton() {
        const undoBtn = document.getElementById('undoBtn');
        if (playState.cardStates.length > 0 && !playState.completed) undoBtn.classList.add('visible');
        else undoBtn.classList.remove('visible');
    }

    function checkGameState() {
        const remaining = playState.cards.filter(c => !c.used);
        if (remaining.length === 1) {
            const val = remaining[0].value;
            if (Math.abs(val - 24) < 0.0001) handleWin();
            else handleWrongAnswer();
        }
    }

    async function handleWin() {
        playState.completed = true;
        playState.endTime = Date.now();

        const solveTime = playState.startTime ?
            Math.round((playState.endTime - playState.startTime) / 1000) : 0;

        const isPerfect = playState.moves === PERFECT_MOVES && playState.undoCount === 0 && !playState.hinted;
        const isFast = isPerfect && solveTime <= 60;

        if (canUpgradeResult(currentPuzzle.puzzleNum)) {
            gameState.history[currentPuzzle.puzzleNum] = {
                completed: true,
                moves: playState.moves,
                operators: [...playState.operatorHistory],
                undos: playState.undoCount,
                solveTime: solveTime,
                hinted: playState.hinted
            };
        }

        if (!currentPuzzle.isArchive) {
            incrementStreak();
            syncStreakToSupabase();
        }

        saveState();
        updateMoveDots();
        showConfetti();

        // Clean win: fade cards, show big 24
        showCleanWinState();

        const title = document.getElementById('successTitle');
        const subtitle = document.getElementById('successSubtitle');
        const stats = document.getElementById('successStats');

        if (isFast) {
            title.textContent = '‚ö° Perfect + Fast!';
            title.classList.add('perfect');
            subtitle.textContent = `Solved in ${solveTime}s!`;
        } else if (isPerfect) {
            title.textContent = '‚≠ê Perfect!';
            title.classList.add('perfect');
            subtitle.textContent = 'Solved in just 3 moves!';
        } else {
            title.textContent = 'üéâ Nice!';
            title.classList.remove('perfect');
            subtitle.textContent = 'You made 24!';
        }

        stats.innerHTML = playState.hinted ? `Moves: ${playState.moves} (with hint)` : `Moves: ${playState.moves}`;
        showDifficultyBadge(currentPuzzle.puzzleNum);

        document.getElementById('percentileDisplay').textContent = 'Loading...';

        setTimeout(() => {
            document.getElementById('successMessage').classList.add('show');
        }, 500);

        const percentileData = await trackPlay(true);
        displayPercentile(percentileData);

        // Gentle nudge at streak milestones (if not signed in)
        maybeShowSyncNudge();
    }

    function handleWrongAnswer() {
        setTimeout(() => {
            playState.cards = currentPuzzle.numbers.map((v, i) => ({
                value: v, used: false, slot: i
            }));
            playState.selected = [];
            playState.cardStates = [];
            renderCards();
            updateResult();
        }, 800);
    }

    function updateMoveDots() {
        const container = document.getElementById('moveDots');
        container.innerHTML = '';
        const totalDots = Math.max(3, playState.moves);
        for (let i = 0; i < totalDots; i++) {
            const dot = document.createElement('div');
            dot.className = 'move-dot';
            if (i < playState.moves) {
                dot.classList.add(i < 3 ? 'filled' : 'excess');
            } else {
                dot.classList.add('perfect-hint');
            }
            container.appendChild(dot);
        }
    }

    function updateUI() {
        document.getElementById('puzzleNumber').textContent = `#${currentPuzzle.puzzleNum}`;
        document.getElementById('archiveBanner').classList.toggle('show', currentPuzzle.isArchive);
        hideDifficultyBadge();
        updateStreakDisplay();
        updateMoveDots();
    }

    function showConfetti() {
        const container = document.getElementById('confetti');
        const colors = ['#22d3ee', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#fbbf24'];
        for (let i = 0; i < 60; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animation = `confetti-fall ${1.5 + Math.random()}s ease-out forwards`;
            confetti.style.animationDelay = Math.random() * 0.5 + 's';
            confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
            confetti.style.width = (6 + Math.random() * 8) + 'px';
            confetti.style.height = (6 + Math.random() * 8) + 'px';
            container.appendChild(confetti);
        }
        setTimeout(() => { container.innerHTML = ''; }, 3000);
    }

    // Share result
    function generateShareText() {
        const history = gameState.history[currentPuzzle.puzzleNum];
        const isPerfect = history?.completed && history.moves === PERFECT_MOVES && (history.undos || 0) === 0 && !history.hinted;
        const isFast = isPerfect && history?.solveTime && history.solveTime <= 60;
        const operators = history?.operators || playState.operatorHistory;

        const opSymbols = { '+': '‚ûï', '-': '‚ûñ', '*': '‚úñÔ∏è', '/': '‚ûó' };
        const opLine = operators.map(op => opSymbols[op]).join(' ');

        let text = `24 #${currentPuzzle.puzzleNum}\n`;
        text += `${opLine}\n`;
        if (isFast) text += `‚ö° Perfect + Fast!\n`;
        else if (isPerfect) text += `‚≠ê Perfect!\n`;
        text += `üî• ${gameState.streak}\n`;
        text += `${APP_CONFIG.publicUrl}`;
        return text;
    }

    function share() {
        const text = generateShareText();
        if (navigator.share) {
            navigator.share({ text }).catch(() => copyToClipboard(text));
        } else { copyToClipboard(text); }
    }

    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            alert('Copied to clipboard!');
        }).catch(() => { alert(text); });
    }

    // Archive
    let archiveDisplayCount = 30;

    function showArchive() {
        const modal = document.getElementById('archiveModal');
        const list = document.getElementById('archiveList');
        list.innerHTML = '';
        const today = getTodayPuzzleNumber();

        for (let i = 0; i < archiveDisplayCount; i++) {
            const num = today - i;
            if (num < 1) continue;

            const item = document.createElement('div');
            item.className = 'archive-item';
            item.textContent = num;

            const history = gameState.history[num];
            if (history?.completed) {
                const isPerfect = history.moves === PERFECT_MOVES && (history.undos || 0) === 0;
                const isFast = isPerfect && history.solveTime && history.solveTime <= 60;
                if (isFast) item.classList.add('fast-perfect');
                else if (isPerfect) item.classList.add('perfect');
                else item.classList.add('completed');
                if (num !== today) item.classList.add('locked');
            }
            if (num === today) item.classList.add('today');

            item.addEventListener('click', () => {
                modal.classList.remove('show');
                initPuzzle(num, num !== today);
            });
            list.appendChild(item);
        }

        if (today > archiveDisplayCount) {
            const loadMoreBtn = document.createElement('button');
            loadMoreBtn.className = 'load-more-btn';
            loadMoreBtn.textContent = '‚Üì Load More History';
            loadMoreBtn.addEventListener('click', () => {
                archiveDisplayCount += 30;
                showArchive();
            });
            const modalContent = modal.querySelector('.modal');
            const existingBtn = modalContent.querySelector('.load-more-btn');
            if (existingBtn) existingBtn.remove();
            modalContent.insertBefore(loadMoreBtn, modalContent.querySelector('.share-history-btn'));
        }

        modal.classList.add('show');
    }

    // Supabase tracking
    let lastPercentileData = null;

    async function trackPlay(success) {
        if (currentPuzzle.isArchive) return null;
        try {
            const solveTime = playState.startTime ?
                Math.round((playState.endTime - playState.startTime) / 1000) : 0;

            const payload = {
                p_device_id: gameState.deviceId,
                p_puzzle_num: currentPuzzle.puzzleNum,
                p_solved: success,
                p_moves: playState.moves,
                p_solve_time: solveTime,
                p_operators: playState.operatorHistory,
                p_undos: playState.undoCount
            };

            const response = await fetch(`${SUPABASE_URL}/rest/v1/rpc/record_solve`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_KEY,
                    'Authorization': `Bearer ${SUPABASE_KEY}`
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) return null;
            const result = await response.json();
            if (result && result.length > 0) {
                lastPercentileData = result[0];
                return result[0];
            }
            return null;
        } catch (e) {
            console.error('Failed to track play:', e);
            return null;
        }
    }

    async function syncStreakToSupabase() {
        try {
            await fetch(`${SUPABASE_URL}/rest/v1/rpc/update_player_streak`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_KEY,
                    'Authorization': `Bearer ${SUPABASE_KEY}`
                },
                body: JSON.stringify({
                    p_device_id: gameState.deviceId,
                    p_new_streak: gameState.streak,
                    p_freezes: gameState.freezes
                })
            });
        } catch (e) { console.error('Failed to sync streak:', e); }
    }

    function displayPercentile(data) {
        const display = document.getElementById('percentileDisplay');
        if (!data || !data.percentile || !data.total_players) {
            display.textContent = '';
            display.classList.remove('highlight');
            return;
        }
        const p = data.percentile, t = data.total_players;
        let message = '';
        if (p >= 90) { message = `üèÜ Top ${100 - p}% of ${t} players today!`; display.classList.add('highlight'); }
        else if (p >= 75) { message = `‚≠ê Better than ${p}% of ${t} players!`; display.classList.add('highlight'); }
        else if (p >= 50) { message = `üìä Better than ${p}% of ${t} players`; display.classList.remove('highlight'); }
        else { message = `${t} players solved today`; display.classList.remove('highlight'); }
        display.textContent = message;
    }

    // Shake to undo
    let lastShakeTime = 0;
    let shakeEnabled = false;
    const SHAKE_THRESHOLD = 25;
    const SHAKE_TIMEOUT = 800;
    let lastX = 0, lastY = 0, lastZ = 0;

    function handleMotion(event) {
        if (!shakeEnabled || playState.completed) return;
        const acc = event.accelerationIncludingGravity;
        if (!acc || acc.x === null) return;
        const deltaX = Math.abs(acc.x - lastX);
        const deltaY = Math.abs(acc.y - lastY);
        const deltaZ = Math.abs(acc.z - lastZ);
        lastX = acc.x; lastY = acc.y; lastZ = acc.z;
        const totalDelta = deltaX + deltaY + deltaZ;
        const now = Date.now();
        if (totalDelta > SHAKE_THRESHOLD && now - lastShakeTime > SHAKE_TIMEOUT) {
            lastShakeTime = now;
            undo();
        }
    }

    async function requestMotionPermission() {
        if (shakeEnabled) return true;
        try {
            if (typeof DeviceMotionEvent !== 'undefined' &&
                typeof DeviceMotionEvent.requestPermission === 'function') {
                const response = await DeviceMotionEvent.requestPermission();
                if (response === 'granted') {
                    window.addEventListener('devicemotion', handleMotion);
                    shakeEnabled = true;
                    return true;
                }
                return false;
            } else if ('DeviceMotionEvent' in window) {
                window.addEventListener('devicemotion', handleMotion);
                shakeEnabled = true;
                return true;
            }
        } catch (e) { console.error('Motion permission error:', e); }
        return false;
    }

    let motionPermissionRequested = false;
    function maybeRequestMotion() {
        if (!motionPermissionRequested && 'DeviceMotionEvent' in window) {
            motionPermissionRequested = true;
            requestMotionPermission();
        }
    }

    // ============================================================
    // EVENT LISTENERS
    // ============================================================
    document.querySelectorAll('.op-btn').forEach(btn => {
        btn.addEventListener('click', () => applyOperation(btn.dataset.op));
    });

    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('hintBtn').addEventListener('click', useHint);

    // Sync nudge toast handlers
    document.getElementById('syncNudgeLink').addEventListener('click', nudgeOpenSignIn);
    document.getElementById('syncNudgeDismiss').addEventListener('click', dismissSyncNudge);

    // Auth: Google + OTP handlers
    document.getElementById('googleSignInBtn').addEventListener('click', signInWithGoogle);
    document.getElementById('otpSendBtn').addEventListener('click', sendOtpCode);
    document.getElementById('otpVerifyBtn').addEventListener('click', verifyOtpCode);
    document.getElementById('syncSignOutBtn').addEventListener('click', promptSignOut);

    // Allow Enter key in OTP inputs
    document.getElementById('otpEmailInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') sendOtpCode();
    });
    document.getElementById('otpCodeInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') verifyOtpCode();
    });

    document.getElementById('operatorsOverlay').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
            playState.selected = [];
            hideOperators();
            renderCards();
        }
    });

    document.getElementById('puzzleNumber').addEventListener('click', showArchive);
    document.getElementById('closeArchive').addEventListener('click', () => {
        document.getElementById('archiveModal').classList.remove('show');
    });

    document.getElementById('shareBtn').addEventListener('click', share);
    document.getElementById('challengeBtn').addEventListener('click', shareChallenge);
    document.getElementById('shareHistoryBtn').addEventListener('click', shareHistoryGrid);

    document.getElementById('closeSuccessBtn').addEventListener('click', () => {
        document.getElementById('successMessage').classList.remove('show');
    });

    document.getElementById('archiveModal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) e.currentTarget.classList.remove('show');
    });

    // ============================================================
    // BOOT (async to support auth)
    // ============================================================
    async function boot() {
        loadState();
        await updateSyncUI();

        const { data: { session } } = await sb.auth.getSession();
        if (session) {
            await ensureCanonicalDeviceId();
        }

        await syncFromSupabase();
        await syncHistoryFromSupabase();
        updateStreak();
        initPuzzle(getTodayPuzzleNumber(), false);
    }

    boot();

    if (!('ontouchstart' in window)) {
        if ('DeviceMotionEvent' in window && typeof DeviceMotionEvent.requestPermission !== 'function') {
            window.addEventListener('devicemotion', handleMotion);
            shakeEnabled = true;
        }
    }
</script>

</body>
</html>